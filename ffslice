#!/bin/bash
#
# ffslice: slice audio/video files with absolute or relative start/end
#

set -euo pipefail

usage() {
  echo "Usage: $(basename "$0") infile start [end] [outfile]"
  echo "Example: $(basename "$0") audio.wav 3:25 3:35"
  echo "Relative times:"
  echo "  +10   10 seconds after start"
  echo "  -5    5 seconds from the end"
  exit 1
}

[[ $# -lt 2 ]] && usage

infile="$1"; shift
start="$1"; shift
end="${1:-}"; shift || true
outfile="${1:-}"; shift || true

# Convert HH:MM:SS or MM:SS to seconds
timetosec() {
  IFS=: read -r -a parts <<< "$1"
  sec=0
  factor=1
  for (( i=${#parts[@]}-1; i>=0; i-- )); do
    sec=$(( sec + parts[i]*factor ))
    factor=$(( factor*60 ))
  done
  echo "$sec"
}

# Build ffmpeg args
args=()

# Handle start
if [[ "${start:0:1}" == "-" ]]; then
  args+=("-sseof" "$start")
  start_sec=0   # relative from EOF, handled by ffmpeg
else
  start_sec=$(timetosec "$start")
  args+=("-ss" "$start_sec")
fi

# Input file
args+=("-i" "$infile")

# Handle end
if [[ -n "$end" ]]; then
  if [[ "${end:0:1}" == "+" ]]; then
    # relative to start
    dur=${end:1}
    args+=("-t" "$dur")
  elif [[ "${end:0:1}" == "-" ]]; then
    args+=("-to" "$end")
  else
    end_sec=$(timetosec "$end")
    if [[ "${start:0:1}" == "-" ]]; then
      echo "Absolute end time not supported when start is relative to EOF"
      exit 1
    fi
    dur=$(( end_sec - start_sec ))
    if (( dur <= 0 )); then
      echo "Error: end must be after start"
      exit 1
    fi
    args+=("-t" "$dur")
  fi
fi

# Output file
if [[ -z "$outfile" ]]; then
  base="${infile%.*}"
  ext="${infile##*.}"
  outfile="${base}-${start}-${end}.${ext}"
elif [[ -d "$outfile" ]]; then
  # If outfile is a directory, generate filename inside it
  base="$(basename "${infile%.*}")"
  ext="${infile##*.}"
  outfile="${outfile}/${base}-${start}-${end}.${ext}"
fi
outfile="${outfile//:/.}"  # replace colon

# Slice audio/video (redirect output to stderr, forward extra args)
set +x
ffmpeg "${args[@]}" -c copy "$@" "$outfile" 1>&2
set -x

# Output the final absolute path
printf '%s' "$(readlink -f "$outfile")"
