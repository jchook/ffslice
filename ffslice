#!/bin/bash
#
# ffslice: slice audio/video files with absolute or relative start/end
#

usage() {
  echo "Usage: $(basename "$0") infile start [end] [outfile] [ffmpeg-args]"
  echo "Example: $(basename "$0") audio.wav 3:25 3:35"
  echo "Relative times:"
  echo "  +10   10 seconds after start"
  echo "  -5    5 seconds from the end"
  exit 1
}

# Convert HH:MM:SS or MM:SS to seconds
timetosec() {
  IFS=: read -r -a parts <<< "$1"
  sec=0
  factor=1
  for (( i=${#parts[@]}-1; i>=0; i-- )); do
    part="${parts[i]//[!0-9]/}"
    sec=$(( sec + 10#${parts[i]} * factor ))
    factor=$(( factor * 60 ))
  done
  echo "$sec"
}

ffslice() {
  set -euo pipefail

  [[ $# -lt 2 ]] && usage

  local infile="$1"; shift
  local start="$1"; shift
  local end="${1:-}"; shift || true
  local outfile="${1:-}"; shift || true

  # Build ffmpeg args
  local args=()
  local start_sec start_eof_sec end_sec end_eof_sec dur

  # +42 in the beginning means the same as 42
  if [[ "${start:0:1}" == "+" ]]; then
    start="${start:1}"
  fi

  # Handle start
  if [[ "${start:0:1}" == "-" ]]; then
    start_eof_sec=$(timetosec "${start:1}")
    args+=("-sseof" "-$start_eof_sec")
    start_sec=0   # relative from EOF, handled by ffmpeg
  else
    start_sec=$(timetosec "$start")
    args+=("-ss" "$start_sec")
  fi

  # Input file
  args+=("-i" "$infile")

  # Handle end
  if [[ -n "$end" ]]; then
    if [[ "${end:0:1}" == "+" ]]; then
      # relative to start
      dur=$(timetosec "${end:1}")
      args+=("-t" "$dur")
    elif [[ "${end:0:1}" == "-" ]]; then
      end_eof_sec=$(timetosec "${end:1}")
      args+=("-to" "-$end_eof_sec")
    else
      end_sec=$(timetosec "$end")
      if [[ "${start:0:1}" == "-" ]]; then
        echo "Absolute end time not supported when start is relative to EOF"
        exit 1
      fi
      dur=$(( end_sec - start_sec ))
      if (( dur <= 0 )); then
        echo "Error: end must be after start"
        exit 1
      fi
      args+=("-t" "$dur")
    fi
  fi

  # Output file
  if [[ -z "$outfile" ]]; then
    local base="${infile%.*}"
    local ext="${infile##*.}"
    outfile="${base}-${start}-${end}.${ext}"
  elif [[ -d "$outfile" ]]; then
    # If outfile is a directory, generate filename inside it
    local base="$(basename "${infile%.*}")"
    local ext="${infile##*.}"
    outfile="${outfile}/${base}-${start}-${end}.${ext}"
  fi

  # Cannot have colon in the filename with ffmpeg
  # https://unix.stackexchange.com/questions/412519/ffmpeg-protocol-not-found-for-normal-file-name
  outfile="${outfile//:/.}"

  # Slice audio/video (redirect output to stderr, forward extra args)
  if [ -n "${FFSLICE_DRY_RUN:-}" ]; then
    # Dry-run mode: print the command instead of executing it
    echo "ffmpeg ${args[*]} -c copy $* $outfile"
  else
    set +x
    ffmpeg "${args[@]}" -c copy "$@" "$outfile" 1>&2
    # Output the final absolute path
    printf '%s' "$(readlink -f "$outfile")"
    set -x
  fi
}

# Only run ffslice if not being sourced (for testing)
if [[ "${BASH_SOURCE[0]:-}" == "${0}" ]]; then
  ffslice "$@"
fi
